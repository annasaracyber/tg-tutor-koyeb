import os, re, asyncio, logging
from typing import List, Optional
from fastapi import FastAPI
from telethon import events
from telethon.sessions import StringSession
from telethon import TelegramClient
import uvicorn
from datetime import datetime, timedelta, timezone  # –¥–ª—è –±—ç—Å–∫–∞–Ω–∞ –∏—Å—Ç–æ—Ä–∏–∏

# ---------- –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —á–µ—Ä–µ–∑ –æ–∫—Ä—É–∂–µ–Ω–∏–µ ----------
API_ID = int(os.environ["API_ID"])           # —á–∏—Å–ª–æ —Å my.telegram.org
API_HASH = os.environ["API_HASH"]            # —Å—Ç—Ä–æ–∫–∞ —Å my.telegram.org
TG_STRING_SESSION = os.environ["TG_STRING_SESSION"]  # —Ç–≤–æ–π –¥–ª–∏–Ω–Ω—ã–π –∫–ª—é—á
CHANNELS = os.getenv("CHANNELS", "").strip() # —Å–ø–∏—Å–æ–∫ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é: @chat1,@chat2
MINUS_WORDS = os.getenv("MINUS_WORDS", "")   # –º–∏–Ω—É—Å-—Å–ª–æ–≤–∞ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é (–Ω–∞–ø—Ä–∏–º–µ—Ä: "—à–∫–æ–ª–∞,–∫–ª–∞—Å—Å,–æ–±–µ–¥,—Å—Ç–æ–ª–æ–≤–∞—è,–¥–æ–º–∞—à–∫–∞,—É—á–µ–Ω–∏–∫,–¥–∏—Ä–µ–∫—Ç–æ—Ä")

# ---------- –∫–ª—é—á–µ–≤—ã–µ –≥—Ä—É–ø–ø—ã ----------
LANG_PATTERNS = [
    # –∞–Ω–≥–ª–∏–π—Å–∫–∏–π
    r"\b–∞–Ω–≥–ª–∏–π—Å–∫\w*\b", r"\b–∞–Ω–≥–ª\b", r"\benglish\b", r"\bIELTS\b", r"\bTOEFL\b",
    # –∏—Å–ø–∞–Ω—Å–∫–∏–π
    r"\b–∏—Å–ø–∞–Ω—Å–∫\w*\b", r"\bspanish\b", r"\bDELE\b",
    # –∏—Ç–∞–ª—å—è–Ω—Å–∫–∏–π
    r"\b–∏—Ç–∞–ª—å—è–Ω—Å–∫\w*\b", r"\bitalian\b", r"\bCELI\b", r"\bCILS\b",
    # –∫–∏—Ç–∞–π—Å–∫–∏–π
    r"\b–∫–∏—Ç–∞–π—Å–∫\w*\b", r"\bchinese\b", r"\bHSK\b",
]

ROLE_PATTERNS = [
    r"\b—Ä–µ–ø–µ—Ç–∏—Ç–æ—Ä\w*\b",
    r"\b–ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª[—å—è]\w*\b",
    r"\b—É—á–∏—Ç–µ–ª[—å—è]\w*\b",  # –æ—Å—Ç–∞–≤–∏–º, –Ω–æ –æ–Ω–æ —Å–∞–º–æ –ø–æ —Å–µ–±–µ –Ω–µ —Ç—Ä–∏–≥–≥–µ—Ä–∏—Ç –±–µ–∑ —è–∑—ã–∫–∞ + –Ω–∞–º–µ—Ä–µ–Ω–∏—è
]

SCHOOL_PATTERNS = [
    r"\b–æ–Ω–ª–∞–π–Ω[- ]?—à–∫–æ–ª\w*\b",
    r"\b–∫—É—Ä—Å—ã?\b", r"\b–∑–∞–Ω—è—Ç–∏—è\b", r"\b—É—Ä–æ–∫(?:–∏|–æ–≤)?\b",
    r"\b–ø–æ–¥–≥–æ—Ç–æ–≤–∫\w*\b",  # –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ —ç–∫–∑–∞–º–µ–Ω–∞–º –∏ —Ç.–ø.
]

HINT_PATTERNS = [
    r"\b–∏—â—É\b", r"\b–Ω—É–∂–µ–Ω\b", r"\b–Ω—É–∂–Ω–∞\b", r"\b–Ω—É–∂–Ω–æ\b",
    r"\b–ø–æ—Ä–µ–∫–æ–º–µ–Ω–¥—É–π—Ç–µ\b", r"\b–ø–æ—Å–æ–≤–µ—Ç—É–π—Ç–µ\b", r"\b–∫—Ç–æ\s+–º–æ–∂–µ—Ç\s+–ø–æ—Å–æ–≤–µ—Ç–æ–≤–∞—Ç—å\b",
    r"\brecommend\b", r"\blooking\s+for\b", r"\bneed\b",
]

def _rx_or(parts: List[str]) -> re.Pattern:
    return re.compile("|".join(parts), re.IGNORECASE | re.MULTILINE) if parts else re.compile(r"^\b$")

# –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ–≥—ç–∫—Å–ø—ã
RX_LANG   = _rx_or(LANG_PATTERNS)
RX_ROLE   = _rx_or(ROLE_PATTERNS)
RX_SCHOOL = _rx_or(SCHOOL_PATTERNS)
RX_HINT   = _rx_or(HINT_PATTERNS)

# –º–∏–Ω—É—Å-—Å–ª–æ–≤–∞ –∏–∑ –æ–∫—Ä—É–∂–µ–Ω–∏—è
MINUS = [w.strip() for w in MINUS_WORDS.split(",") if w.strip()]
RX_MINUS = _rx_or([re.escape(w) for w in MINUS]) if MINUS else None

def norm(s: Optional[str]) -> str:
    return re.sub(r"\s+", " ", (s or "").replace("\u200b", "")).strip()

def looks_like_request(text: str) -> bool:
    """
    –ñ—ë—Å—Ç–∫–∏–π —Ñ–∏–ª—å—Ç—Ä:
    - –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –µ—Å—Ç—å –æ–¥–∏–Ω –∏–∑ —è–∑—ã–∫–æ–≤ (RX_LANG)
    - –∏ (—Ä–æ–ª—å —Ä–µ–ø–µ—Ç–∏—Ç–æ—Ä–∞/–ø—Ä–µ–ø–æ–¥–∞ –ò–õ–ò —à–∫–æ–ª–∞/–∫—É—Ä—Å—ã)  => RX_ROLE or RX_SCHOOL
    - –∏ –≤—ã—Ä–∞–∂–µ–Ω–∞ –∏–Ω—Ç–µ–Ω—Ü–∏—è (RX_HINT –ò–õ–ò –≤–æ–ø—Ä–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –∑–Ω–∞–∫/—Å–ª–æ–≤–∞-—Ç—Ä–∏–≥–≥–µ—Ä—ã)
    - –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –º–∏–Ω—É—Å-—Å–ª–æ–≤
    """
    t = norm(text)
    if not t:
        return False
    if RX_MINUS and RX_MINUS.search(t):
        return False

    if not RX_LANG.search(t):
        return False

    has_role_or_school = bool(RX_ROLE.search(t) or RX_SCHOOL.search(t))
    if not has_role_or_school:
        return False

    hinted = bool(
        RX_HINT.search(t) or
        re.search(r"[?]|–ø–æ–¥—Å–∫–∞–∂–∏—Ç–µ|–ø–æ—Å–æ–≤–µ—Ç—É–π—Ç–µ|–∏—â—É|–Ω—É–∂–µ–Ω|–Ω—É–∂–Ω–∞|–Ω—É–∂–Ω–æ|–ø–æ—Ä–µ–∫–æ–º–µ–Ω–¥(—É–π|—É–π—Ç–µ)", t, re.IGNORECASE)
    )
    return hinted

# ---------- Telegram client ----------
client = TelegramClient(StringSession(TG_STRING_SESSION), API_ID, API_HASH)

app = FastAPI()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("uvicorn")

# –±—É–¥–µ–º —Ö—Ä–∞–Ω–∏—Ç—å —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω—ã–µ chat_id (–µ—Å–ª–∏ CHANNELS –ø—É—Å—Ç–æ–π ‚Äî —Å–ª—É—à–∞–µ–º –≤—Å–µ)
allowed_chat_ids: Optional[set[int]] = None

async def resolve_entities():
    """–ó–∞–ø–æ–ª–Ω—è–µ–º allowed_chat_ids –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π CHANNELS.
    –ï—Å–ª–∏ CHANNELS –ø—É—Å—Ç ‚Äî —Å–ª—É—à–∞–µ–º –≤—Å–µ —á–∞—Ç—ã."""
    global allowed_chat_ids
    if not CHANNELS:
        allowed_chat_ids = None
        logger.info("–°–ª—É—à–∞–µ–º: –í–°–ï —á–∞—Ç—ã (CHANNELS –ø—É—Å—Ç–æ–π)")
        return

    names = [x.strip() for x in CHANNELS.split(",") if x.strip()]
    ids = set()
    for name in names:
        try:
            ent = await client.get_entity(name)
            ids.add(getattr(ent, "id", None))
        except Exception as e:
            logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å {name}: {e}")
    allowed_chat_ids = {i for i in ids if i is not None}
    logger.info(f"–°–ª—É—à–∞–µ–º —á–∞—Ç—ã/–∫–∞–Ω–∞–ª—ã: {len(allowed_chat_ids)}")

def public_link(username: Optional[str], mid: int) -> str:
    return f"https://t.me/{username}/{mid}" if username else ""

# ---------- —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ ----------
async def scan_recent(days: int = 4, max_per_chat: int = 2000) -> int:
    """
    –ü—Ä–æ–π—Ç–∏—Å—å –ø–æ —á–∞—Ç–∞–º/–∫–∞–Ω–∞–ª–∞–º –∏ –Ω–∞–π—Ç–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ `days` –¥–Ω–µ–π,
    –ø–æ—Ö–æ–∂–∏–µ –Ω–∞ –∑–∞–ø—Ä–æ—Å —Ä–µ–ø–µ—Ç–∏—Ç–æ—Ä–∞. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —á–∏—Å–ª–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π.
    """
    cutoff = datetime.now(timezone.utc) - timedelta(days=days)

    # –Ω–∞–±–∏—Ä–∞–µ–º —Å–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π –¥–ª—è –ø—Ä–æ—Ö–æ–¥–∞
    entities = []
    if allowed_chat_ids is None:
        async for d in client.iter_dialogs():
            if getattr(d, "is_group", False) or getattr(d, "is_channel", False):
                entities.append(d.entity)
    else:
        for cid in allowed_chat_ids:
            try:
                entities.append(await client.get_entity(cid))
            except Exception as e:
                logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å entity {cid}: {e}")

    total = 0
    for ent in entities:
        title = getattr(ent, "title", getattr(ent, "username", None)) or str(getattr(ent, "id", ""))
        username = getattr(ent, "username", None)

        async for m in client.iter_messages(ent, limit=max_per_chat):
            if not m or not m.date:
                continue
            if m.date < cutoff:
                break  # –¥–∞–ª—å—à–µ —Å–æ–æ–±—â–µ–Ω–∏—è –µ—â—ë —Å—Ç–∞—Ä—à–µ

            text = m.message or ""
            if not looks_like_request(text):
                continue

            link = public_link(username, m.id)
            msg = (
                "üîé (–∏—Å—Ç–æ—Ä–∏—è) –ó–∞–ø—Ä–æ—Å —Ä–µ–ø–µ—Ç–∏—Ç–æ—Ä–∞ –ø–æ —è–∑—ã–∫–∞–º\n"
                f"üë• –ß–∞—Ç: {title}\n"
                f"üß∑ –°–æ–æ–±—â–µ–Ω–∏–µ #{m.id}\n"
                f"üïí {m.date.astimezone().strftime('%Y-%m-%d %H:%M')}\n"
                f"üîó {link or '(–ø—Ä–∏–≤–∞—Ç–Ω—ã–π —á–∞—Ç)'}\n\n"
                f"{norm(text)}"
            )
            await client.send_message("me", msg)
            total += 1
            await asyncio.sleep(0.2)  # —â–∞–¥–∏–º –ª–∏–º–∏—Ç—ã

    logger.info(f"[SCAN] –ù–∞–π–¥–µ–Ω–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π: {total} (–∑–∞ {days} –¥–Ω.)")
    return total

@app.on_event("startup")
async def on_startup():
    await client.start()
    await resolve_entities()

    # –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–æ–Ω–ª–∞–π–Ω-—Ä–µ–∂–∏–º)
    @client.on(events.NewMessage)
    async def handler(event):
        try:
            if allowed_chat_ids is not None and event.chat_id not in allowed_chat_ids:
                return

            text = event.message.message or ""
            if not looks_like_request(text):
                return

            chat = await event.get_chat()
            username = getattr(chat, "username", None)
            title = getattr(chat, "title", username) or str(getattr(chat, "id", ""))
            link = public_link(username, event.id)

            msg = (
                "üîé –ó–∞–ø—Ä–æ—Å —Ä–µ–ø–µ—Ç–∏—Ç–æ—Ä–∞ –ø–æ —è–∑—ã–∫–∞–º\n"
                f"üë• –ß–∞—Ç: {title}\n"
                f"üß∑ –°–æ–æ–±—â–µ–Ω–∏–µ #{event.id}\n"
                f"üîó {link or '(–ø—Ä–∏–≤–∞—Ç–Ω—ã–π —á–∞—Ç)'}\n\n"
                f"{norm(text)}"
            )
            await client.send_message("me", msg)
            logger.info(f"[MATCH] {title} #{event.id} | {norm(text)[:120]}")
        except Exception as e:
            logger.exception(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞: {e}")

    # Telethon –≤ —Ñ–æ–Ω–µ
    asyncio.create_task(client.run_until_disconnected())
    logger.info("–ö–ª–∏–µ–Ω—Ç Telegram –∑–∞–ø—É—â–µ–Ω.")

    # —Ä–∞–∑–æ–≤—ã–π –±—ç—Å–∫–∞–Ω –∏—Å—Ç–æ—Ä–∏–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 4 –¥–Ω—è –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
    asyncio.create_task(scan_recent(days=4))

@app.get("/")
async def root():
    return {"status": "ok"}

@app.get("/health")
async def health():
    return {"ok": True}

if __name__ == "__main__":
    # Render –∑–∞–¥–∞—ë—Ç PORT; –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 10000
    port = int(os.environ.get("PORT", 10000))
    uvicorn.run(app, host="0.0.0.0", port=port)
