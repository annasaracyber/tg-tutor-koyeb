import os, re, asyncio, logging
from typing import List, Optional
from fastapi import FastAPI
from telethon import events
from telethon.sessions import StringSession
from telethon import TelegramClient

# ---------- –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —á–µ—Ä–µ–∑ –æ–∫—Ä—É–∂–µ–Ω–∏–µ ----------
API_ID = int(os.environ["API_ID"])           # —á–∏—Å–ª–æ —Å my.telegram.org
API_HASH = os.environ["API_HASH"]            # —Å—Ç—Ä–æ–∫–∞ —Å my.telegram.org
TG_STRING_SESSION = os.environ["TG_STRING_SESSION"]  # —Ç–≤–æ–π –¥–ª–∏–Ω–Ω—ã–π –∫–ª—é—á
CHANNELS = os.getenv("CHANNELS", "").strip() # —Å–ø–∏—Å–æ–∫ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é: @chat1,@chat2
MINUS_WORDS = os.getenv("MINUS_WORDS", "")   # –º–∏–Ω—É—Å-—Å–ª–æ–≤–∞ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é

# –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∏ "–ø–æ–¥—Å–∫–∞–∑–∫–∏"
KEYWORDS = [
    r"\b—Ä–µ–ø–µ—Ç–∏—Ç–æ—Ä[–∞-—è]*\b", r"\b–ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª[—å—è][–∞-—è]*\b", r"\b—É—á–∏—Ç–µ–ª[—å—è][–∞-—è]*\b",
    r"\b–∑–∞–Ω—è—Ç–∏—è –ø–æ –∞–Ω–≥–ª[–∞-—è]*\b", r"\b–∞–Ω–≥–ª–∏–π—Å–∫(–∏–π|–æ–≥–æ|–∏–º|–æ–º|–∏–µ)\b", r"\b–∞–Ω–≥–ª\b",
    r"\bIELTS\b", r"\bTOEFL\b", r"\btutor\b", r"\bteacher\b", r"\benglish\b",
]
HINTS = [
    r"\b–ø–æ—Ä–µ–∫–æ–º–µ–Ω–¥—É–π—Ç–µ\b", r"\b–º–æ–∂–µ—Ç–µ –ª–∏ –ø–æ—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞—Ç—å\b",
    r"\b–Ω—É–∂–µ–Ω(–∞|–æ)? —Ä–µ–ø–µ—Ç–∏—Ç–æ—Ä\b", r"\b–∏—â—É —Ä–µ–ø–µ—Ç–∏—Ç–æ—Ä–∞\b",
    r"\b–∫—Ç–æ –º–æ–∂–µ—Ç –ø–æ—Å–æ–≤–µ—Ç–æ–≤–∞—Ç—å\b",
    r"\brecommend( an? )?english (tutor|teacher)\b",
    r"\bIELTS (coach|tutor|teacher)\b",
]

def _rx_or(parts: List[str]) -> re.Pattern:
    return re.compile("|".join(parts), re.IGNORECASE | re.MULTILINE) if parts else re.compile(r"^\b$")

RX_KEY = _rx_or(KEYWORDS)
RX_HINT = _rx_or(HINTS)

MINUS = [w.strip() for w in MINUS_WORDS.split(",") if w.strip()]
RX_MINUS = _rx_or([re.escape(w) for w in MINUS]) if MINUS else None

def norm(s: Optional[str]) -> str:
    return re.sub(r"\s+", " ", (s or "").replace("\u200b", "")).strip()

def looks_like_request(text: str) -> bool:
    t = norm(text)
    if not t or not RX_KEY.search(t):
        return False
    if RX_MINUS and RX_MINUS.search(t):
        return False
    if RX_HINT.search(t):
        return True
    return bool(re.search(r"[?]|–ø–æ–¥—Å–∫–∞–∂–∏—Ç–µ|–ø–æ—Å–æ–≤–µ—Ç—É–π—Ç–µ|–∏—â—É|–Ω—É–∂–µ–Ω|–≥–¥–µ –Ω–∞–π—Ç–∏", t, re.IGNORECASE))

# ---------- Telegram client ----------
client = TelegramClient(StringSession(TG_STRING_SESSION), API_ID, API_HASH)

app = FastAPI()
logger = logging.getLogger("uvicorn")
logger.setLevel(logging.INFO)

entities_cache = None  # —Å–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π —á–∞—Ç–æ–≤ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞

async def resolve_entities():
    global entities_cache
    if not CHANNELS:
        entities_cache = None  # —Å–ª—É—à–∞—Ç—å –≤—Å–µ –¥–∏–∞–ª–æ–≥–∏
        logger.info("–°–ª—É—à–∞–µ–º: –í–°–ï —á–∞—Ç—ã (CHANNELS –ø—É—Å—Ç–æ–π)")
        return
    names = [x.strip() for x in CHANNELS.split(",") if x.strip()]
    ents = []
    for name in names:
        try:
            ent = await client.get_entity(name)
            ents.append(ent)
        except Exception as e:
            logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å {name}: {e}")
    entities_cache = ents
    logger.info(f"–°–ª—É—à–∞–µ–º —á–∞—Ç—ã/–∫–∞–Ω–∞–ª—ã: {len(ents)}")

def public_link(username: Optional[str], mid: int) -> str:
    return f"https://t.me/{username}/{mid}" if username else ""

@app.on_event("startup")
async def on_startup():
    await client.start()
    await resolve_entities()

    @client.on(events.NewMessage(chats=lambda _: entities_cache))
    async def handler(event):
        try:
            text = event.message.message or ""
            if not looks_like_request(text):
                return
            chat = await event.get_chat()
            username = getattr(chat, "username", None)
            title = getattr(chat, "title", username) or str(getattr(chat, "id", ""))
            link = public_link(username, event.id)

            msg = (
                "üîé –ó–∞–ø—Ä–æ—Å —Ä–µ–ø–µ—Ç–∏—Ç–æ—Ä–∞ –ø–æ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º—É\n"
                f"üë• –ß–∞—Ç: {title}\n"
                f"üß∑ –°–æ–æ–±—â–µ–Ω–∏–µ #{event.id}\n"
                f"üîó {link or '(–ø—Ä–∏–≤–∞—Ç–Ω—ã–π —á–∞—Ç)'}\n\n"
                f"{norm(text)}"
            )
            # –æ—Ç–ø—Ä–∞–≤–∏–º –≤ ¬´–ò–∑–±—Ä–∞–Ω–Ω–æ–µ¬ª (Saved Messages)
            await client.send_message("me", msg)
            logger.info(f"[MATCH] {title} #{event.id} | {norm(text)[:120]}")

        except Exception as e:
            logger.exception(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞: {e}")

    # –¥–µ—Ä–∂–∏–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å Telegram –≤ —Ñ–æ–Ω–µ
    asyncio.create_task(client.run_until_disconnected())
    logger.info("–ö–ª–∏–µ–Ω—Ç Telegram –∑–∞–ø—É—â–µ–Ω.")

@app.get("/")
async def root():
    return {"status": "ok"}

@app.get("/health")
async def health():
    return {"ok": True}
